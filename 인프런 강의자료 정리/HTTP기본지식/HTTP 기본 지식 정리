
IP
인터넷 프로토콜 역할
• 지정한 IP 주소(IP Address)에 데이터 전달
• 패킷(Packet)이라는 통신 단위로 데이터 전달


IP 프로토콜의 한계
 - 비연결성
• 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송(IP 프로토콜은 대상 서버가 패킷을 받을 수 있는 상태인지 모름 - 전원이 꺼져있어도 전송)
 - 비신뢰성
• 중간에 패킷이 사라지면? (걸국 여러 서버들을 거쳐가는거라 중간에 뭔일이 일어날지 알수가 없음)
• 패킷이 보낸 순서대로 안오면? (보낼 데이터의 크기가 클 경우 패킷을 쪼개서 보내게 되는데 회선따라 다른 노드를 타게되는 경우가 있음. 도착지점에 누가 먼저 올지는 몰?루)
 - 프로그램 구분
• 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이면?

---------------------------------------------------------------------------------------
 " TCP/UDP "
<!--"인터넷 프로토콜 스택의 4계층"-->
 애플리케이션 계층 - HTTP, FTP
 전송 계층 - TCP, UDP
 인터넷 계층 - IP
 네트워크 인터페이스 계층
  ===> 각각의 계층을 거치면서 데이터에 필요한 계층들을 포장시켜서 패킷을 만듬.
 
 
 TCP 특징
전송 제어 프로토콜(Transmission Control Protocol)
• 연결지향 - "TCP 3 way handshake" (가상 연결 => 가상으로 한번 연결해서 받을 준비가 되어 있는지 상태를 본다)
• 데이터 전달 보증 (데이터 전송을 잘 받았는지 응답을 서버에서 같이 담아서 답장해 줌)
• 순서 보장 (패킷 순서가 다르게 도착하면 재대로 안 온 순서부터 다시 보내라고 서버가 재응답 함)
• 신뢰할 수 있는 프로토콜
• 현재는 대부분 TCP 사용

---------------------------------------------------------------------------------------
-- TCP 3 way handshake
클라이언트 - 서버간 상호 교신

==> 중간에 거치는 수많으 서버들과 노드들이 어떤지는 모른다.
==> 그냥 목적지에 보내 봤고 응답이 왔다는 것을 확인한 것. 전용 통로 같은 것은 없다.

클라이언트ㅣ   =>   SYN       ㅣ 서버
          ㅣ     SYN, ACK  <= ㅣ
          ㅣ   =>   ACK       ㅣ

* SYN: 접속 요청
* ACK: 요청 수락
---------------------------------------------------------------------------------------

 UDP 특징
 -사용자 데이터그램 프로토콜(User Datagram Protocol)
• 하얀 도화지에 비유(기능이 거의 없음)
• 연결지향 - TCP 3 way handshake X
• 데이터 전달 보증 X
• 순서 보장 X
• !!!! 데이터 전달 및 순서가 보장되지 않지만, 단순하고 빠름 !!!! => TCP는 신뢰성을 위해 이것저것 사전작업을 많이해서 상대적으로 느리다.
• 정리
• IP와 거의 같다. <+PORT> <+체크섬(간단한 검증)> 정도만 추가
• 애플리케이션에서 추가 작업 필요
---------------------------------------------------------------------------------------

<!-- 포트(PORT) -->
 목적지 서버를 찾아가기 위해 "IP" 가 필요. 그럼 그 서버안에서 이제 누가 한 요청인지 식별하기 위해서는 "PORT" 활용
   • 0 ~ 65535 할당 가능
     • 0 ~ 1023: 잘 알려진 포트, 사용하지 않는 것이 좋음
     • FTP - 20, 21
     • TELNET - 23
     • HTTP - 80
     • HTTPS - 443
     
<!-- DNS(도메인 네임 시스템(Domain Name System)  EX) google, naver, kakao...) --> 
 IP는 기억하기 어렵다 + IP는 변경될 수 있다
 => 도메인 명을 IP 주소로 변환(DNS서버에 IP를 등록해 놓고 만약 서비스 과정에서 IP가 바뀔일이 있다면 해당 서버에 등록된 주소를 UPDATE 해줌)
 => 클라이언트가 어디에 접속하고 싶다면 DNS를 가지고 도메인 서버에 접속해서 IP의 값을 받아온 뒤 그 주소로 요청을 보냄.
 
 
 
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
<!-- URI -->
  • Uniform: 리소스 식별하는 통일된 방식
  • Resource: 자원, URI로 식별할 수 있는 모든 것(제한 없음)
  • Identifier: 다른 항목과 구분하는데 필요한 정보
  => URI >> URL, URN

  • URL: Uniform Resource Locator
  • URN: Uniform Resource Name (거의 사용할 일이 없다)
 
 ==> 지금은 그냥 URL만 쓴다. 따라서 URI = URL로 봐도 무방
 
---------------------------------------------------------------------------------------
 URL의 문법

• scheme://[userinfo@]host[:port][/path][?query][#fragment]
• https://www.google.com:443/search?q=hello&hl=ko
       ㅣ
       \/
• scheme: //[userinfo@ => 유저의 사용자 정보 인증시 사용 거의 안씀] host[:port]           [/path]  [?query]       [#fragment : html 내부북마크에서 사용, 서버로 전송X]
•  https: //                                                       www.google.com:443    /search   ?q=hello&hl=ko

• 프로토콜(https)
• 호스트명(www.google.com)
• 포트 번호(443)
• 패스(/search)
• 쿼리 파라미터(q=hello&hl=ko)
---------------------------------------------------------------------------------------
 웹 브라우저의 요청 흐름
 어플리케이션에서 HTTP 요청 메세지 작성 = > OS에서 TCP/IP 소켓을 씌워서 포장함 => 서버로 날림
 서버에서는 도착한 TCP/IP 소켓을 까서 버림. HTTP메세지만 해석해서 적합한 응답을 구성함. 구성한 HTTP 응답에 마찬가지로 TCP/IP소켓으로 포장함 => 클라이언트에게 날림
 클라이언트도 마찬가지로 돌아온 응답에서 TCP/IP소켓을 까서 버림. 그리고 남은 HTTP응답을 구성해서 UI에 출력
 
 
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
"HTTP"
 HyperText Transfer Protocol
 
모든 것이 HTTP
HTTP 메시지에 모든 것을 전송

• HTML, TEXT
• IMAGE, 음성, 영상, 파일
• JSON, XML (API)
• 거의 모든 형태의 데이터 전송 가능
• 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용
• 지금은 HTTP 시대!

---------------------------------------------------------------------------------------
HTTP 역사
• HTTP/0.9 1991년: GET 메서드만 지원, HTTP 헤더X
• HTTP/1.0 1996년: 메서드, 헤더 추가
***** HTTP/<1.1 version> 1997년: 가장 많이 사용, 우리에게 가장 중요한 버전 *****
   • RFC2068 (1997) -> RFC2616 (1999) -> RFC7230~7235 (2014)
• HTTP/2 2015년: 성능 개선
• HTTP/3 진행중: TCP 대신에 UDP 사용, 성능 개선

기반 프로토콜
• TCP: HTTP/1.1, HTTP/2
• UDP: HTTP/3
• 현재 HTTP/1.1 주로 사용
• HTTP/2, HTTP/3 도 점점 증가


---------------------------------------------------------------------------------------
<HTTP 특징>
• 클라이언트 서버 구조
  - "Request Response" 구조
  - 클라이언트는 서버에 요청을 보내고, 응답을 대기
  - 서버가 요청에 대한 결과를 만들어서 응답 (클라이언트와 서버를 구별하게 됨으로써 각자 역할을 분업-전문화 하는게 가능해짐)

• 무상태 프로토콜(Stateless)
  - 서버가 클라이언트의 상태를 보존X
  - 장점: 서버 확장성 높음(스케일 아웃(수평 확장)) => 동일 기능의 아무 서버에 연결되어도 무관, 만약 상태가 유지된다면 상태를 유지중인 그 특정 서버에만 연결해야됨.
  - 단점: 클라이언트가 매번 추가 데이터 전송 => 로그인 서비스 같은 경우 브라우저가 쿠키값을 응답에 같이 보내도록 강제됨. (서버의 세션으로 검증)
  ※ 무상태성을 기억해라. 특히 특정시간 이벤트나 명절 KTX 이벤트의 경우 진짜 동시에 수만의 요청이 폭주해서 들어온다. 악으로 깡으로 무상태성 맞게 짜야한다.
     실무에서는 로그인도 필요없는 무상태성 정적페이지를 하나 뿌리고 사람들이 거기서 살짝 시간을 보내고 참가 버튼을 누르도록 유도한다. (약간이라도 동시접속을 분산 위해)

• 비연결성
  - HTTP는 기본이 연결을 유지하지 않는 모델
  - 일반적으로 초 단위의 이하의 빠른 속도로 응답
  - 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작음 => 서버 자원을 매우 효율적으로 사용할 수 있음
  >> 한계점
  - TCP/IP 연결을 새로 맺어야 함 => 3 way handshake 시간 추가
  - 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, css, 추가 이미지 등등 수 많은 자원이 함께 다운로드
  - 지금은 HTTP 지속 연결(Persistent Connections)로 문제 해결 (HTTP/2, HTTP/3에서 더 많은 최적화)
    ===> 무조건으로 연결을 끊는 것 보다 모든 응답이 끝날 때 까지 연결을 유지하는 것이 결론적으로 더 시간과 자원을 감소시킴.

• HTTP 메시지
  - HTTP 메세지의 구조
     --------------------------------                                요청                                                 응답
    ㅣ      start-line 시작 라인     ㅣ => request-line (GET,POST,PUT,DELETE)(요청대상+[쿼리)(HTTP버전)   / status-line (HTTP버전)(상태 메세지)
     --------------------------------
    ㅣ          header 헤더          ㅣ =>                        Host:DNS주소                           / HTTP전송에 필요한 온갖 부가정보(표준 헤더필더 개많음)
     --------------------------------
    ㅣempty line 공백라인(CRLF(필수))ㅣ 
     --------------------------------
    ㅣ         message body          ㅣ =>        실제 전송할 데이터 / HTML 문서, 이미지, 영상, JSON 등등 byte로 표현할 수 있는 모든 데이터 전송 가능
     --------------------------------
     
      HTTP-message = start-line 
                    *( header-field CRLF ) 
                    CRLF 
                    [ message-body ]
     
• 단순함, 확장 가능



---------------------------------------------------------------------------------------
HTTP 메서드 종류

  주요 메서드
 • GET: 리소스 조회
 • POST: 요청 데이터 처리, 주로 등록에 // 사용 예) POST /orders/{orderId}/start-delivery (컨트롤 URI) => 애매하면 그냥 일단 무조건 포스트
 • PUT: 리소스를 대체, 해당 리소스가 없으면 생성
    - 리소스를 대체
      • 리소스가 있으면 대체
      • 리소스가 없으면 생성
      • 쉽게 이야기해서 덮어버림
      • 중요! 클라이언트가 리소스를 식별
      • 클라이언트가 리소스 위치를 알고 URI 지정

• DELETE: 리소스 삭제
• PATCH: 리소스 부분 변경 (안되는 서버가 있을수도 있음. 그래서 잘 안씀. 대신 POST 쓰면됨.)


  기타 메서드
 • HEAD: GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환
 • OPTIONS: 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명(주로 CORS에서 사용)
 • CONNECT: 대상 자원으로 식별되는 서버에 대한 터널을 설정
 • TRACE: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행
 
 
 
 ---------------------------------------------------------------------------------------
 HTTP 메서드의 속성
  • 안전(Safe Methods)
  • 멱등(Idempotent Methods)
  • 캐시가능(Cacheable Methods)


 1) 안전
 - Safe
 • 호출해도 리소스를 변경하지 않는다.
 • Q: 그래도 계속 호출해서, 로그 같은게 쌓여서 장애가 발생하면요?
 • A: 안전은 해당 리소스만 고려한다. 그런 부분까지 고려하지 않는다.


  2) 멱등
  - Idempotent
  • f(f(x)) = f(x)
  • 한 번 호출하든 두 번 호출하든 100번 호출하든 결과가 똑같다.
    ! 멱등 메서드
    • GET: 한 번 조회하든, 두 번 조회하든 같은 결과가 조회된다.
    • PUT: 결과를 대체한다. 따라서 "같은 요청"을 여러번 해도 "최종 결과"는 같다.
    • DELETE: 결과를 삭제한다. 같은 요청을 여러번 해도 삭제된 결과는 똑같다.
       !!※POST: 멱등이 `아니다`!!! 두 번 호출하면 같은 결제가 중복해서 발생할 수 있다.
  • 활용
    • 자동 복구 메커니즘
    • 서버가 TIMEOUT 등으로 정상 응답을 못주었을 때, 클라이언트가 같은 요청을 다시 해도 되는가? 판단 근거
    

  3) 캐시가능
  - Cacheable
  • 응답 결과 리소스를 캐시해서 사용해도 되는가?
  • GET, HEAD, POST, PATCH 캐시가능
  • 실제로는 'GET', 'HEAD' 정도만 캐시로 사용
  • POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데, 구현이 쉽지 않음.
 
 --------------------------------------------------------------------------------------- 
 HTTP 메서드 활용 - 클라이언트에서 서버로 데이터 전송
  데이터 전달 방식은 크게 2가지
    • 쿼리 파라미터를 통한 데이터 전송
    - GET
     • 주로 정렬 필터(검색어)
     • 메시지 바디를 통한 데이터 전송
    - POST, PUT, PATCH
     • 회원 가입, 상품 주문, 리소스 등록, 리소스 변경


  - 정적 / 동적 데이터 조회
   • 조회는 GET 사용
   • 이미지, 정적 텍스트 문서
   • 정적 데이터는 일반적으로 쿼리 파라미터 없이 리소스 경로로 단순하게 조회 가능
   • 조회 조건을 줄여주는 필터, 조회 결과를 정렬하는 정렬 조건에 주로 사용
   
  ※ Content-Type: multipart/form-data ※
    • 파일 업로드 같은 바이너리 데이터 전송시 사용
    • 다른 종류의 여러 파일과 폼의 내용 함께 전송 가능(그래서 이름이 multipart)
      ps.참고: HTML Form 전송은 GET, POST만 지원
      

---------------------------------------------------------------------------------------
 < HTTP API 설계 예시 >  
  
  !!!!! 대부분은 POST기반 '컬렉션'을 사용함.
  --HTTP API - '컬렉션'
    • POST 기반 등록 => 보통 서버에서 Resource Uri를 생성해줌( ex) auto_increment ), 즉 클라이언트가 아니라 서버가 리소스를 결정해줌. =>  <"컬랙션">
    • 예) 회원 관리 API 제공
    
  --HTTP API - 스토어
    • PUT 기반 등록 =>  클라이언트가 파일 이름을 "결정해서" 넘겨줌.(/files/{filename}), 즉 서버대신 클라인트가 스스로 리소스를 관리함. =>  <"스토어">
    • 예) 정적 컨텐츠 관리, 원격 파일 관리
 
  --HTML FORM 사용
    • 웹 페이지 회원 관리
    • GET, POST만 지원
       EX)
        • 회원 목록    /members -> GET
        • 회원 등록폼  /members/new -> GET
        • 회원 등록    /members/new, /members -> POST
        • 회원 조회    /members/{id} -> GET
        • 회원 수정폼  /members/{id}/edit -> GET
        • 회원 수정    /members/{id}/edit, /members/{id} -> POST
        • 회원 삭제    /members/{id}/delete -> POST


<--- 정리 --->
--참고하면 좋은 URI 설계 개념 
 • 문서(document) 
  • 단일 개념(파일 하나, 객체 인스턴스, 데이터베이스 row)
  • 예) /members/100, /files/star.jpg
 
 • 컬렉션(collection) 
  • 서버가 관리하는 리소스 디렉터리
  • 서버가 리소스의 URI를 생성하고 관리
  • 예) /members
 
 • 스토어(store) 
  • 클라이언트가 관리하는 자원 저장소
  • 클라이언트가 리소스의 URI를 알고 관리
  • 예) /files
 
 • 컨트롤러(controller), 컨트롤 URI 
  • 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행
  • 동사를 직접 사용
  • 예) /members/{id}/delete
       
       -https://restfulapi.net/resource-naming

---------------------------------------------------------------------------------------
<-- Http 상태코드 -->
<결제 시스탬이나 회원가입 처럼 한번만 요청보내고 성공적으로 서버에 등록시 중복을 막기 위한 응답코드>
  "302 Found" => location에 주소를 담아서 응답해주면 클라이언트 브라우저가 자동으로 해당 주소로 redirect 수행한다. 이렇게 될 경우
고객이 F5로 새로고침을 할 경우에도 이전 명령어가 Redirect된 주소로 덮어 씌우기 때문에 중복 등록/주문을 막을 수 있다.
 PS) 물론 당연히 서버쪽에서 이러한 일이 안생기도록 검사장치를 당연히 만들기는 해야한다. 통신오류나 여러 이유로 중복 요청이 될수도 있기 때문.
 
 PS) 중복 확인시에는 409 Conflict를 주로 사용합니다.
 
 
 
 
