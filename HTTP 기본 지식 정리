IP
인터넷 프로토콜 역할
• 지정한 IP 주소(IP Address)에 데이터 전달
• 패킷(Packet)이라는 통신 단위로 데이터 전달


IP 프로토콜의 한계
 - 비연결성
• 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송(IP 프로토콜은 대상 서버가 패킷을 받을 수 있는 상태인지 모름 - 전원이 꺼져있어도 전송)
 - 비신뢰성
• 중간에 패킷이 사라지면? (걸국 여러 서버들을 거쳐가는거라 중간에 뭔일이 일어날지 알수가 없음)
• 패킷이 보낸 순서대로 안오면? (보낼 데이터의 크기가 클 경우 패킷을 쪼개서 보내게 되는데 회선따라 다른 노드를 타게되는 경우가 있음. 도착지점에 누가 먼저 올지는 몰?루)
 - 프로그램 구분
• 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이면?

---------------------------------------------------------------------------------------
 " TCP/UDP "
<!--"인터넷 프로토콜 스택의 4계층"-->
 애플리케이션 계층 - HTTP, FTP
 전송 계층 - TCP, UDP
 인터넷 계층 - IP
 네트워크 인터페이스 계층
  ===> 각각의 계층을 거치면서 데이터에 필요한 계층들을 포장시켜서 패킷을 만듬.
 
 
 TCP 특징
전송 제어 프로토콜(Transmission Control Protocol)
• 연결지향 - "TCP 3 way handshake" (가상 연결 => 가상으로 한번 연결해서 받을 준비가 되어 있는지 상태를 본다)
• 데이터 전달 보증 (데이터 전송을 잘 받았는지 응답을 서버에서 같이 담아서 답장해 줌)
• 순서 보장 (패킷 순서가 다르게 도착하면 재대로 안 온 순서부터 다시 보내라고 서버가 재응답 함)
• 신뢰할 수 있는 프로토콜
• 현재는 대부분 TCP 사용

---------------------------------------------------------------------------------------
-- TCP 3 way handshake
클라이언트 - 서버간 상호 교신

==> 중간에 거치는 수많으 서버들과 노드들이 어떤지는 모른다.
==> 그냥 목적지에 보내 봤고 응답이 왔다는 것을 확인한 것. 전용 통로 같은 것은 없다.

클라이언트ㅣ   =>   SYN       ㅣ 서버
          ㅣ     SYN, ACK  <= ㅣ
          ㅣ   =>   ACK       ㅣ

* SYN: 접속 요청
* ACK: 요청 수락
---------------------------------------------------------------------------------------

 UDP 특징
 -사용자 데이터그램 프로토콜(User Datagram Protocol)
• 하얀 도화지에 비유(기능이 거의 없음)
• 연결지향 - TCP 3 way handshake X
• 데이터 전달 보증 X
• 순서 보장 X
• !!!! 데이터 전달 및 순서가 보장되지 않지만, 단순하고 빠름 !!!! => TCP는 신뢰성을 위해 이것저것 사전작업을 많이해서 상대적으로 느리다.
• 정리
• IP와 거의 같다. <+PORT> <+체크섬(간단한 검증)> 정도만 추가
• 애플리케이션에서 추가 작업 필요
---------------------------------------------------------------------------------------

<!-- 포트(PORT) -->
 목적지 서버를 찾아가기 위해 "IP" 가 필요. 그럼 그 서버안에서 이제 누가 한 요청인지 식별하기 위해서는 "PORT" 활용
   • 0 ~ 65535 할당 가능
     • 0 ~ 1023: 잘 알려진 포트, 사용하지 않는 것이 좋음
     • FTP - 20, 21
     • TELNET - 23
     • HTTP - 80
     • HTTPS - 443
     
<!-- DNS(도메인 네임 시스템(Domain Name System)  EX) google, naver, kakao...) --> 
 IP는 기억하기 어렵다 + IP는 변경될 수 있다
 => 도메인 명을 IP 주소로 변환(DNS서버에 IP를 등록해 놓고 만약 서비스 과정에서 IP가 바뀔일이 있다면 해당 서버에 등록된 주소를 UPDATE 해줌)
 => 클라이언트가 어디에 접속하고 싶다면 DNS를 가지고 도메인 서버에 접속해서 IP의 값을 받아온 뒤 그 주소로 요청을 보냄.
 
 
 
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
<!-- URI -->
  • Uniform: 리소스 식별하는 통일된 방식
  • Resource: 자원, URI로 식별할 수 있는 모든 것(제한 없음)
  • Identifier: 다른 항목과 구분하는데 필요한 정보
  => URI >> URL, URN

  • URL: Uniform Resource Locator
  • URN: Uniform Resource Name (거의 사용할 일이 없다)
 
 ==> 지금은 그냥 URL만 쓴다. 따라서 URI = URL로 봐도 무방
 
---------------------------------------------------------------------------------------
 URL의 문법

• scheme://[userinfo@]host[:port][/path][?query][#fragment]
• https://www.google.com:443/search?q=hello&hl=ko
       ㅣ
       \/
• scheme: //[userinfo@ => 유저의 사용자 정보 인증시 사용 거의 안씀] host[:port]           [/path]  [?query]       [#fragment : html 내부북마크에서 사용, 서버로 전송X]
•  https: //                                                       www.google.com:443    /search   ?q=hello&hl=ko

• 프로토콜(https)
• 호스트명(www.google.com)
• 포트 번호(443)
• 패스(/search)
• 쿼리 파라미터(q=hello&hl=ko)
---------------------------------------------------------------------------------------
 웹 브라우저의 요청 흐름
 어플리케이션에서 HTTP 요청 메세지 작성 = > OS에서 TCP/IP 소켓을 씌워서 포장함 => 서버로 날림
 서버에서는 도착한 TCP/IP 소켓을 까서 버림. HTTP메세지만 해석해서 적합한 응답을 구성함. 구성한 HTTP 응답에 마찬가지로 TCP/IP소켓으로 포장함 => 클라이언트에게 날림
 클라이언트도 마찬가지로 돌아온 응답에서 TCP/IP소켓을 까서 버림. 그리고 남은 HTTP응답을 구성해서 UI에 출력
 
 
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
"HTTP"
 HyperText Transfer Protocol
 
모든 것이 HTTP
HTTP 메시지에 모든 것을 전송

• HTML, TEXT
• IMAGE, 음성, 영상, 파일
• JSON, XML (API)
• 거의 모든 형태의 데이터 전송 가능
• 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용
• 지금은 HTTP 시대!

---------------------------------------------------------------------------------------
HTTP 역사
• HTTP/0.9 1991년: GET 메서드만 지원, HTTP 헤더X
• HTTP/1.0 1996년: 메서드, 헤더 추가
***** HTTP/<1.1 version> 1997년: 가장 많이 사용, 우리에게 가장 중요한 버전 *****
   • RFC2068 (1997) -> RFC2616 (1999) -> RFC7230~7235 (2014)
• HTTP/2 2015년: 성능 개선
• HTTP/3 진행중: TCP 대신에 UDP 사용, 성능 개선

기반 프로토콜
• TCP: HTTP/1.1, HTTP/2
• UDP: HTTP/3
• 현재 HTTP/1.1 주로 사용
• HTTP/2, HTTP/3 도 점점 증가


---------------------------------------------------------------------------------------
<HTTP 특징>
• 클라이언트 서버 구조
  - "Request Response" 구조
  - 클라이언트는 서버에 요청을 보내고, 응답을 대기
  - 서버가 요청에 대한 결과를 만들어서 응답 (클라이언트와 서버를 구별하게 됨으로써 각자 역할을 분업-전문화 하는게 가능해짐)

• 무상태 프로토콜(Stateless)
  - 서버가 클라이언트의 상태를 보존X
  - 장점: 서버 확장성 높음(스케일 아웃(수평 확장)) => 동일 기능의 아무 서버에 연결되어도 무관, 만약 상태가 유지된다면 상태를 유지중인 그 특정 서버에만 연결해야됨.
  - 단점: 클라이언트가 매번 추가 데이터 전송 => 로그인 서비스 같은 경우 브라우저가 쿠키값을 응답에 같이 보내도록 강제됨. (서버의 세션으로 검증)
  ※ 무상태성을 기억해라. 특히 특정시간 이벤트나 명절 KTX 이벤트의 경우 진짜 동시에 수만의 요청이 폭주해서 들어온다. 악으로 깡으로 무상태성 맞게 짜야한다.
     실무에서는 로그인도 필요없는 무상태성 정적페이지를 하나 뿌리고 사람들이 거기서 살짝 시간을 보내고 참가 버튼을 누르도록 유도한다. (약간이라도 동시접속을 분산 위해)

• 비연결성
  - HTTP는 기본이 연결을 유지하지 않는 모델
  - 일반적으로 초 단위의 이하의 빠른 속도로 응답
  - 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작음 => 서버 자원을 매우 효율적으로 사용할 수 있음
  >> 한계점
  - TCP/IP 연결을 새로 맺어야 함 => 3 way handshake 시간 추가
  - 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, css, 추가 이미지 등등 수 많은 자원이 함께 다운로드
  - 지금은 HTTP 지속 연결(Persistent Connections)로 문제 해결 (HTTP/2, HTTP/3에서 더 많은 최적화)
    ===> 무조건으로 연결을 끊는 것 보다 모든 응답이 끝날 때 까지 연결을 유지하는 것이 결론적으로 더 시간과 자원을 감소시킴.

• HTTP 메시지
  - HTTP 메세지의 구조
     --------------------------------                                요청                                                 응답
    ㅣ      start-line 시작 라인     ㅣ => request-line (GET,POST,PUT,DELETE)(요청대상+[쿼리)(HTTP버전)   / status-line (HTTP버전)(상태 메세지)
     --------------------------------
    ㅣ          header 헤더          ㅣ =>                        Host:DNS주소                           / HTTP전송에 필요한 온갖 부가정보(표준 헤더필더 개많음)
     --------------------------------
    ㅣempty line 공백라인(CRLF(필수))ㅣ 
     --------------------------------
    ㅣ         message body          ㅣ =>        실제 전송할 데이터 / HTML 문서, 이미지, 영상, JSON 등등 byte로 표현할 수 있는 모든 데이터 전송 가능
     --------------------------------
     
      HTTP-message = start-line 
                    *( header-field CRLF ) 
                    CRLF 
                    [ message-body ]
     
• 단순함, 확장 가능



 
 
 
